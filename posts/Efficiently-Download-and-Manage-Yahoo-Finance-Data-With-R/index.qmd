---
title: "How to Download and Efficiently Manage Stock Data from Yahoo! Finance for Multiple Tickers using R"
description: "ETL routines using functional programming for working with large sets of stock-level data simultaneously."
author:
  - name: Lucas S. Macoris
    url: https://lsmacoris.github.io/
    orcid: 0000-0003-0732-5011
    affiliation: Ph.D. in Economics @ INSPER (Sao Paulo, Brazil) | Data Science @ Circana
    affiliation-url: https://www.circana.com/
date: 9-27-2023
categories: [Yahoo! Finance, Stocks,R] # self-defined categories
citation: 
  url: https://lsmacoris.github.io/posts/Efficiently-Download-and-Manage-Yahoo-Finance-Data-With-R
image: post_thumbnail.jpg
draft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

## Downloading Multiple Stock-level Information from Yahoo! Finance using R

Whenever downloading data from *Yahoo! Finance* using `quantmod`, I've always found it difficult to organize a collection of objects in cases where the number of requested tickers large. Not only for the sake of organization, sometimes we want to perform calculations that span a large set of assets and visualize results in an aggregate fashion. For example, say that one wants estimate how persistent prices for several stocks are using past information. The naivest way to do it would be to loop over several tickers, collect the metric, and append to a `data.frame()` that will be used to analyze metrics (*i.e*, using histograms and summary statistics).

Although this is totally up to you, I've selected a few packages that make the overall explanation easier:

```{r,warning=FALSE,error=FALSE,message=FALSE,results='hide'}

packages.to.load=c("ggplot2","dplyr","PerformanceAnalytics","quantmod","xts","purrr","glue")

#Load all packages
sapply(packages.to.load,library,character.only = TRUE)

```

Using  the `getSymbols()` function from `quantmod`, we can loop over a list of stocks and collect the information:

```{r}

list_of_assets=c('AAPL','MSFT','GOOG','GOOGL','AMZN','NVDA','TSLA')

for (assets in list_of_assets){
  getSymbols(assets)
}
```

...which, by default, will load each individual `asset` in the `list_of_assets` that was passed to `GetSymbols()` in your `R` session:

![Figure 1: R-Session-Overloaded](r-session-example.jpg)

## Handling Multiple Tickers from Yahoo! Finance

In this very simple example, having a list of seven distinct does not create a messy `R` environment to work, but that can easily be the case in applications where you need to constantly track a higher number of stocks. Likewise, since you've downloaded data for multiple tickers, it is likely the case that you need to perform operations for each asset. In this case, since each assets is loaded as a `.xts` object in your session, you might need to `loop` over each asset in order to perform a given operation.

Say, for example, that after loading the data, we wanted to calculate a 30-day moving average and store the results. Since each `asset` has been loaded separately in our session, we need to iterate over each asset, collect the column that we want to calculate a moving-average, and collapse the results:

```{r}
#Initialize an empty xts to collect information
SMA_df=xts()

for(asset in list_of_assets){
  
  #Collect the Close column and perform a moving average
  SMA_df=SMA_df%>%merge.xts(get(asset)[,glue('{asset}.Close')]%>%SMA(30)%>%setNames(glue('{asset}_SMA')))
  
}

#Plot xts
plot.xts(SMA_df,main='30-day moving average\nfor selected U.S. stocks')
addLegend("topleft",legend.names = list_of_assets,col=1:length(list_of_assets),lty=1)

```

Well, that seemed to do the trick. However, is this something that we might want to adopt for all cases with multiple tickers? Probably not. If the number of tickers is large (e.g, $>>100$) and the calculations that we need to perform are more computational-intensive, such as extracting a time-series component from our data, iterating over assets using `for` loops will be an inneficient way of handling these tasks, as each computation will require you to loop over different `.xts` objects stored in your session.

## Applying Functional Programming to Stock-Level Information

I happened to find `purrr` (see [documentation](https://purrr.tidyverse.org)) to be a handy companion for tasks like this. When using its functional programming features, not only we can have an easier way to work with multiple tickers, but also work with a much cleaner environment -- as no one  wants to have 100+ `xts` objects in our environment everytime when running the code.

This notebook showcases how to collect and organize data from *Yahoo! Finance* and perform calculations that span across all tickers. This can be very useful, for example, when creating an automated screening system in which, based on a set of technical indicators, can easily run a screening process in order to select a bundle of assets for a given trading strategy.

I am  going to present a simple example using a set of brazilian traded stocks traded in *Bovespa*. All the stocks are presented in the auxiliary *.csv* file, `Assets.csv`, and can be changed to accomodate any stock available in *Yahoo! Finance* servers. This file contains approximataely 75 unique tickers from the Brazilian Stock Market that were tradable back in 2019. What makes it difficult to use `quantmod`'s capabilities is the fact that some tickers are not available and/or do not have data for the requested period. Whenever running a `for` loop and iterate through these tickers, one might come across a `warning` or an `error` message that crashes the task. To overcome such difficulty, I have developed some wrappers using the `tryCatch()` approach.

**Important Remark**: *Yahoo! Finance* generally offers data with splits and dividends adjustments and therefore may not be the same as the brokerage information. In this sense, recommendations must also be analyzed through technical indicators presented on the brokerage account. Additionally, one can change the log in order to use any other provider of financial data of the same format, such as [*AlphaVantage*](https://www.alphavantage.co/), which also has an API support into the `quantmod` library.

## Using Functional Programming with Yahoo! Finance in R

After loading the data, we can iterate through our list of tickers to organize the information. One important callout is that whenever we want to retrieve some technical indicators (for example, from the `TTR` package), we need to ensure that there are no `NA`s in our data. For that, we'll wrap our call using the `na.locf()` call to repeat the latest information available:

```{r}

#Load the list of Assets
Assets<-read.csv('Assets.csv',sep=';',encoding = 'UTF-8',header = TRUE,stringsAsFactors = FALSE)[,1]

#Let's take a look at the structure of the file
Assets%>%head(5)

#create empty data.frames to collect downloaded and error cases
downloaded=data.frame()
errors=data.frame()

#Getting Data: now, we are going to request for chunks of 5 assets per time in Yahoo Finance server.

adjust_ticker_data <- function(ticker){
  
  return(na.locf(Cl(ticker)))
  
}

Tickers=list()

for (i in Assets){

  Data=suppressWarnings(
      tryCatch({
      
      adjust_ticker_data(getSymbols(i,
                                    auto.assign = FALSE,
                                    from='2019-01-01',to=Sys.Date())
                         )},
      error = function(e){
      assign("errors",rbind(errors,i),envir=.GlobalEnv)
      }
    )
  )
  
#If successful, we'll be able to have a xts object to get information on prices:
  
  if(is.xts(Data)){
  downloaded=downloaded%>%rbind(i)
  Bands = do.call(merge,lapply(Data,BBands))
  RSI = do.call(merge,lapply(Data,RSI))
  SMA= do.call(merge,lapply(Data,SMA))
  
  Tickers[[i]]=list(Data=Data,
                    BBands=Bands,
                    RSI=RSI,
                    SMA=SMA)
  
  #Clear from memory to avoid if conditions to be satisfied with past iterations
  rm(Data,Bands,RSI,SMA)
  }

}

  #Retrieve status information:
  message(glue('Data not downloaded for the following tickers: {errors}.'))
  message(glue('Successfully downloaded data for the following tickers: {downloaded}.'))

```

What is very interesting when collecting information using lists is that we can easily organize data in a streamlined fashion that is very flexible when working with different data structure dimensions. For example, when inspecting the newly created `Tickers` list, it contains:

1. A first layer of 64 named lists, one for each ticker that has been successfully downloaded;
2. One additional layer for the adjusted closing data; and
3. Additional layers for each technical indicator

Due to the way that it was structured, these objects do not need to hold a specific row $\times$ column dimension, as every object is stored in a single nested list, making our life much easier when dealing with multiple tickers:

![Figure 2: R Session when using list-like methods.](r-session-purrr.jpg)

![Figure 3: Structure of a list with multiple tickers](r-list-structure.jpg)

## Retrieve List Information with Functional Programming using purrr

Using `purrr` capabilities for functional programming can make overwhelming tasks that involve multiple tickers much easier. More specifically, `map` and its companions allow us to map functions across different lists, collect objects, and pipe it for other analysis and/or visualizations. Say, for example, that we want to understand what is the distribution of price persistence across *all* tickers. We can run an $ARIMA(p,d,q)$ model for each ticker, collec the coefficients, and then plot an histogram to understand the distribution of the autoregressive component, $p$.

In order to do that, we will create a new list that will extract all `Data` components of the nested ticker lists. With that, we will use a combination of the `map_*` family functions from `purrr` to feed the results directly into a `ggplot` chart -- everything without creating a single new object!

```{r,warning=FALSE}

#Using map_* + ggplot to analyze the distribution of the autoregressive parameter 

suppressWarnings(lapply(Tickers,'[[',"Data")%>%
  map(arima,order=c(1,1,1)))%>%
  map("coef")%>%
  map_df('ar1')%>%t()%>%as.data.frame()%>%
  ggplot(aes(x=V1))+
  geom_histogram(binwidth = 0.1)+
  theme_minimal()+
  labs(x='Autoregressive Parameter',
       y='Count',
       title='Distribution of autoregressive parameters across Brazilian stocks',
       subtitle='Assuming an ARIMA(1,1,1) model for the stocks')+
  scale_y_continuous(breaks=seq(1,10,1))+
  scale_x_continuous(breaks=seq(-1,1,0.15))+
  geom_density(aes(y=0.075*..count..),size=1,col='red',linetype='dashed')

```

## Final Thoughts: Financial Data with Functional Programming in R 

This example outlines just a simple application of functional programming for a situation where there are several nested lists holding diverse structures. However, applications go far beyond than that, and it is something that I would definitely recommend to anyone that is working with stock price data that spans multiple tickers.

I definitely recommend going through the documentation of the packages used herein, as well as investigating some other very interesting variations of *Yahoo! Finance* data collection in R. In special, the `yfR` (see documentation [here](https://github.com/ropensci/yfR)) package uses parallel computing to speed up the processing time when downloading multiple tickers.
